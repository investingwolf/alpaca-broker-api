/**
 * Alpaca Broker API
 * Open brokerage accounts, enable commission-free trading, and manage the ongoing user experience with Alpaca Broker API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/// <reference types="node" />
import http from 'http';
import { ACHRelationshipData } from '../model/aCHRelationshipData';
import { ACHRelationshipResource } from '../model/aCHRelationshipResource';
import { Account } from '../model/account';
import { AccountCreationObject } from '../model/accountCreationObject';
import { AccountExtended } from '../model/accountExtended';
import { AccountUpdate } from '../model/accountUpdate';
import { BankData } from '../model/bankData';
import { BankResource } from '../model/bankResource';
import { DocumentUpload } from '../model/documentUpload';
import { InlineResponse200 } from '../model/inlineResponse200';
import { InlineResponse20010 } from '../model/inlineResponse20010';
import { InlineResponse2005 } from '../model/inlineResponse2005';
import { TransferData } from '../model/transferData';
import { TransferResource } from '../model/transferResource';
import { Authentication, Interceptor } from '../model/models';
import { HttpBasicAuth } from '../model/models';
export declare enum AccountsApiApiKeys {
}
export declare class AccountsApi {
    protected _basePath: string;
    protected _defaultHeaders: any;
    protected _useQuerystring: boolean;
    protected authentications: {
        default: Authentication;
        BasicAuth: HttpBasicAuth;
    };
    protected interceptors: Interceptor[];
    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    set useQuerystring(value: boolean);
    set basePath(basePath: string);
    set defaultHeaders(defaultHeaders: any);
    get defaultHeaders(): any;
    get basePath(): string;
    setDefaultAuthentication(auth: Authentication): void;
    setApiKey(key: AccountsApiApiKeys, value: string): void;
    set username(username: string);
    set password(password: string);
    addInterceptor(interceptor: Interceptor): void;
    /**
     *
     * @summary Upload a document to an already existing account
     * @param accountId Account identifier.
     * @param documentUpload
     */
    accountsAccountIdDocumentsUploadPost(accountId: string, documentUpload: DocumentUpload, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     *
     * @summary Retrieve specific account activities
     * @param activityType
     */
    accountsActivitiesActivityTypeGet(activityType: 'FILL' | 'ACATC' | 'ACATS' | 'CSD' | 'CSR' | 'CSW' | 'DIV' | 'DIVCGL' | 'DIVCGS' | 'DIVNRA' | 'DIVROC' | 'DIVTXEX' | 'INT' | 'JNLC' | 'JNLS' | 'MA' | 'NC' | 'PTC' | 'REORG' | 'SSO' | 'SSP', options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: InlineResponse20010;
    }>;
    /**
     *
     * @summary Retrieve account activities
     * @param activityType The type of activity you wish to query
     * @param date
     * @param until
     */
    accountsActivitiesGet(activityType?: 'FILL' | 'ACATC' | 'ACATS' | 'CSD' | 'CSR' | 'CSW' | 'DIV' | 'DIVCGL' | 'DIVCGS' | 'DIVNRA' | 'DIVROC' | 'DIVTXEX' | 'INT' | 'JNLC' | 'JNLS' | 'MA' | 'NC' | 'PTC' | 'REORG' | 'SSO' | 'SSP', date?: string, until?: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: InlineResponse20010;
    }>;
    /**
     *
     * @summary Retrieve all accounts
     * @param query The query supports partial match of account number, names, emails, etc.. Items can be space delimited.
     */
    accountsGet(query?: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: Array<AccountExtended>;
    }>;
    /**
     *
     * @summary Create an account
     * @param accountCreationObject
     */
    accountsPost(accountCreationObject: AccountCreationObject, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: Account;
    }>;
    /**
     *
     * @summary Request to close an account
     * @param accountId Account identifier.
     */
    deleteAccount(accountId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     *
     * @summary Delete an existing ACH relationship
     * @param accountId Account identifier.
     * @param achRelationshipId ACH relationship identifier
     */
    deleteAchRelationship(accountId: string, achRelationshipId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     *
     * @summary Delete a Bank Relationship for an account
     * @param accountId Account identifier.
     * @param bankId
     */
    deleteRecipientBank(accountId: string, bankId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     *
     * @summary Request to close a transfer
     * @param accountId
     * @param transferId
     */
    deleteTransfer(accountId: string, transferId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body?: any;
    }>;
    /**
     * Query Params Rules: - `since` required if `until` specified - `since_id` required if `until_id` specified - `since` and `since_id` canâ€™t be used at the same time Behavior: - if `since` or `since_id` not specified this will not return any historic data - if `until` or `until_id` reached stream will end (status 200)
     * @summary Subscribe to account status events (SSE).
     * @param since
     * @param until
     * @param sinceId
     * @param untilId
     */
    eventsAccountsStatusGet(since?: Date, until?: Date, sinceId?: number, untilId?: number, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: InlineResponse2005;
    }>;
    /**
     * The response is an Account model.
     * @summary Retrieve an account.
     * @param accountId Account identifier.
     */
    getAccount(accountId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: AccountExtended;
    }>;
    /**
     *
     * @summary Retrieve ACH Relationships for an account
     * @param accountId Account identifier.
     * @param statuses Comma-separated status values
     */
    getAchRelationships(accountId: string, statuses?: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: Array<ACHRelationshipResource>;
    }>;
    /**
     *
     * @summary Retrieve bank relationships for an account
     * @param accountId
     * @param status
     * @param bankName
     */
    getRecipientBanks(accountId: string, status?: string, bankName?: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: Array<BankResource>;
    }>;
    /**
     * The response is a Trading Account model.
     * @summary Retrieve trading details for an account.
     * @param accountId Account identifier.
     */
    getTradingAccount(accountId: string, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: InlineResponse200;
    }>;
    /**
     * You can filter requested transfers by values such as direction and status.
     * @summary Return a list of transfers for an account.
     * @param accountId
     * @param direction
     * @param limit
     * @param offset
     */
    getTransfers(accountId: string, direction?: 'INCOMING' | 'OUTGOING', limit?: number, offset?: number, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: Array<TransferResource>;
    }>;
    /**
     *
     * @summary Update an account
     * @param accountId Account identifier.
     * @param accountUpdate
     */
    patchAccount(accountId: string, accountUpdate: AccountUpdate, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: Account;
    }>;
    /**
     *
     * @summary Create an ACH Relationship
     * @param accountId Account identifier.
     * @param aCHRelationshipData
     */
    postAchRelationships(accountId: string, aCHRelationshipData: ACHRelationshipData, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: ACHRelationshipResource;
    }>;
    /**
     *
     * @summary Create a Bank Relationship for an account
     * @param accountId Account identifier.
     * @param bankData
     */
    postRecipientBanks(accountId: string, bankData: BankData, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: BankResource;
    }>;
    /**
     * This operation allows you to fund an account with virtual money in the sandbox environment.
     * @summary Request a new transfer
     * @param accountId
     * @param transferData
     */
    postTransfers(accountId: string, transferData: TransferData, options?: {
        headers: {
            [name: string]: string;
        };
    }): Promise<{
        response: http.IncomingMessage;
        body: TransferResource;
    }>;
}
